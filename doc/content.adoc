= bytebuf - A library for working with ByteBuffer's
Andrey Antukh, <niwi@niwi.be>
0.1.0
:toc: left
:numbered:
:source-highlighter: pygments
:pygments-style: friendly
:sectlinks:

== Introduction

Working with raw bytes is tedious, and sometimes the language abstractions for working
with bytes is not very pleasant.

_bytebuf_ library offers a simple api for working with raw byte arrays and compose binary protocols
for two most used clojure implementations: clojure (jvm) and clojurescript (javascript).


== Project Maturity

Since _bytebuf_ is a young project there can be some API breakage.


== Install

This section covers the _bytebuf_ library installing process and its requirements.


=== Requirements

_bytebuf_ is tested with these platforms:

- JDK7
- JDK8
- Node 0.12
- iojs 1.4.1


=== Leiningen

The simplest way to use _suricatta_ in a clojure project, is by including it in the dependency
vector on your *_project.clj_* file:

._on project.clj_
[source,clojure]
----
[funcool/bytebuf "0.1.0"]
----

=== Get the Code

_bytebuf_ is open source and can be found on link:https://github.com/funcool/bytebuf[github].

You can clone the public repository with this command:

[source,text]
----
git clone https://github.com/funcool/bytebuf
----


== Getting started

The main goal of _bytebuf_ is provide, multiplatform abstraction for work with bytebuffer's. For it
offers a ligweight api for define message types in a declarative way and use them for read or
write to bytebuffers.

As previously said, _bytebuf_  works with both most used clojure implementations: clojure & clojurescript. Each platform has own bytebuffer like types. _bytebuf_ library offers implementations for link:http://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html[NIO ByteBuffer] and link:http://netty.io/4.1/api/io/netty/buffer/ByteBuf.html[Netty ByteBuf] in clojure and link:https://developer.mozilla.org/en/docs/Web/JavaScript/Typed_arrays[es6 typed arrays] in clojurescript.


=== Define a spec

A spec in _bytebuf_ glossary represents a type definition or a composition of types. Two most common
composition types are: associative and indexed.

The difference of indexed and associative compositions is the input and output. In associative
composition the expected input and output is a map like object. And in indexed composition,
the expected input and input is a vector like objects. Internally them represents the same value in
bytes.

Let start defining one:

[source, clojure]
----
(require '[bytebuff.core :as buf])

;; Indexed composition
(def my-spec1 (buf/spec (buf/int32) (buf/bool)))

;; The same spec but using associative composition
(def my-spec2 (buf/spec :field1 (buf/int32)
                        :field2 (buf/bool)))
----

You can check that the spec size (in bytes) and number of types internally is the same
for both defined specs:

[source, clojure]
----
(buf/size my-spec1)
;; => 5

(count my-spec1)
;; => 2

(buf/size my-spec2)
;; => 5

(count my-spec2)
;; => 2
----

The `spec` is a polimorphic constructor for type specs compostion, that dependently of specified
arguments, creates a indexed composition instance or associatieve.


=== Creating buffer

The next piece in the puzzle is a way to create (or allocate) new byte buffers. This operation is
almost platform independent if the defaults satisfies you.

.Example allocating a 24 bytes size byte buffer with *default* implementation:
[source, clojure]
----
;; Allocate bytebuffer with 24 bytes of size
(def buffer (buf/allocate 24))
----

.Example allocating a 24 bytes size byte buffer of *heap* type using *NIO* implementation:
[source, clojure]
----
;; This is a default if you are using clojure
(def buffer (buf/allocate 24 {:impl :nio :type :heap}))
----

.Example allocating a 24 bytes size byte buffer of *heap* type using *es6 typed arrays* implementation:
[source, clojure]
----
;; This is a default if you are using clojurescript
(def buffer (buf/allocate 24 {:impl :es6 :type :heap}))
----

You can see all supported options <<supported-bytebuffers,here>>

The return value of `allocate` depens on implementation used. Is a plain instance without additional
wrapping. If you want access to its internals, you can do it with native host platform api.


=== Read and write data

It's time to see how we can write data to buffers and read data from them. Specs are simple schema
on how the data should be read or write to the buffer.

.Example writing data into buffer using indexed composed schema
[source, clojure]
----
;; The indexed composed spec exptects a vector as input
(buf/write! buffer [22 true] my-spec1)
;; => 5
----

The `write!` function  returns a number of bytes are written into buffer.

As, previously mentioned, indexed and associative specs with same fields (in same order) represents
the identical byte layout. Knowing that, we also can do the same operation but using the associative
spec defined previously:

.Example writing data into buffer using a map as input
[source, clojure]
----
(buf/write! buffer {:field1 22 :field2 true} my-spec2)
;; => 5
----

Secondly, the read operation is mostly similar to write one. It reads from buffer following the
spec data definition and return corresponding data structure or plain value.

.Example reading data using indexed spec.
[source, clojure]
----
(buf/read buffer my-spec1)
;; => [22 true]
----

Also, you can perform the same operation, but using a associative spec:

.Example reading data using associative spec.
[source, clojure]
----
(buf/read buffer my-spec2)
;; => {:field1 22 :field2 true}
----

NOTE: This works idependently of implementation used for allocate the buffer. Some implementations
has little limitations, es6 (cljs) as example, des not support `int64` typespec due to platform
limitations.

Composed type specs and plain value type specs implements the same abstraction and both can be used
directly in read and write operations.

.Use *int16* as spec for read from buffer.
[source, clojure]
----
(buf/read buffer (buf/int16))
;; => 22
----


== Advanced usage

=== Read & Write with offset.

If you know that the data what you want read is located in a specific position in a buffer, you
can specify it in a read or write operation:

.Example writing data in specific offset
[source, clojure]
----
(buf/write buffer [0 false] my-spec1 {:offset 20})
;; => [0 false]
----

.Example read data from specific offset.
[source, clojure]
----
(buf/read buffer my-spec1 {:offset 20})
;; => [0 false]
----

=== Show readed bytes.

The default `read` function returns readed data but not returns a amount of readed bytes. For it,
_bytebuf_ exposes a convenience function `read*` that instead of return only readed data, returns
a vector with amount of bytes readed and the readed data:

.Example using `read*` function
[source, clojure]
----
(buf/read* buffer my-spec2)
;; => [5 {:field1 22 :field2 true}]
----

=== Read & Write repeatedly

At this moment, _bytebuf_ does not incluedes facilities for create repeated compositions, but it can
be solved using normal clojure primitives for it.

.Example repeatedly write data into buffer using the same spec.
[source, clojure]
----
(def spec (buf/spec (buf/int16) (buf/int16)))

(reduce (fn [offset data]
          (let [written (buf/write! buffer data spec {:offset offset})]
            (+ offset written)))
        0
        [[1 2] [3 4] [5 6]])
;; => 12
----

.Example read three times from buffer using the same spec
[source, clojure]
----
(reduce (fn [acc offset]
          (conj acc (buf/read buffer spec {:offset offset})))
        []
        (range 0 10 4))
;; => [[1 2] [3 4] [5 6]]
----

In future versions, this surelly will be improved providing facilities for
create repeated compositions.

=== Using arbitrary size type specs

Until now, we have seen examples alway using fixed size compositions. Fixed size compositions
are easy understand, the size of the spec can be know in any time. But in some circumstances
we want store arbitrary length types.

Arbitrary lenght strings is a clear example, and _bytebuf_ comes with that type spec implemented:

.Example writing arbitrary length string into buffer
[source, clojure]
----
(buf/write! buffer "hello world" (buf/string*))
;; => 15
----

.Example reading arbitrary length string from buffer
[source, clojure]
----
(buf/read buffer (buf/string*))
;; => "hello world"
----

But, how it works? Type specs like that, is a composition of two typespecs: *int32* and
fixed length *string*. On write phase, it calculates the size of string, writes firstly the size
as `int32` following of fixed size string. The read phase is like write but in backward direction.

Also, the size of that type spec depends on data and can not be known outsize of read/write phase:

.Example how obtain a size of specific type spec
[source, clojure]
----
(buf/size (buf/int16))
;; => 2

(buf/size (buf/string*))
;; => IllegalArgumentException No implementation of method: :size of protocol: #'bytebuf.proto/IStaticSize found for class: bytebuf.spec.string$string_STAR_$reify__1804  clojure.core/-cache-protocol-fn (core_deftype.clj:555)
----

== Additional info

[[supported-bytebuffers]]
=== Supported byte buffers

This is a complete table of supported byte buffer implementations and type of byte buffers:

[cols="1,2,2", options="header"]
|=========================================
| Platform | Name | Params
| Clojure | Heap NIO ByteBuffer | `{:type :heap :impl :nio}`
| Clojure | Direct NIO ByteBuffer | `{:type :direct :impl :nio}`
| Clojure | Heap Netty ByteBuf | `{:type :heap :impl :netty}`
| Clojure | Direct Netty ByteBuf | `{:type :direct :impl :netty}`
| ClojureScript | Heap ES6 ArrayBuffer/DataView | `{:type :heap :impl :es6}`
|=========================================


=== Supported typespecs

This is a complete list of supported plain value type spec:

[cols="1,1,1,2", options="header"]
|====================================================================
| Name    | Function      | Size (in bytes) | Notes
| Short   | `buf/int16`   | 2               |
| Integer | `buf/int32`   | 4               |
| Long    | `buf/int64`   | 8               | Only on jvm
| Float   | `buf/float`   | 4               |
| Double  | `buf/double`  | 8               |
| Boolean | `buf/bool`    | 1               |
| Byte    | `buf/byte`    | 1               |
| String  | `buf/string`  | N               | Fixed length string
| String  | `buf/string*` | 4+N             | Arbitrary length string
|====================================================================


Independently if a spec is a value spec or a composition of value specs, all them
implements the same abstraction and can be used in read or write operations.


=== Coming features

- *memoryviews*: abstraction for random read/write access to buffer without parsing
  all spec related data.
- nodejs/iojs buffer support.
- more function for create compositions like repeated type, or key value pairs.


== How to Contribute?

=== Philosophy

Five most important rules:

- Beautiful is better than ugly.
- Explicit is better than implicit.
- Simple is better than complex.
- Complex is better than complicated.
- Readability counts.

All contributions to _bytebuf_ should keep these important rules in mind.


=== Procedure

**bytebuf** unlike Clojure and other Clojure contrib libs, does not have many
restrictions for contributions. Just follow the following steps depending on the
situation:

**Bugfix**:

- Fork the GitHub repo.
- Fix a bug/typo on a new branch.
- Make a pull-request to master.

**New feature**:

- Open new issue with the new feature proposal.
- If it is accepted, follow the same steps as "bugfix".

=== License

_bytebuf_ is licensed under BSD (2-Clause) license:

----
Copyright (c) 2015 Andrey Antukh <niwi@niwi.be>

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
----
