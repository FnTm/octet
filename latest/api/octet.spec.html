<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><title>octet.spec documentation</title></head><body><header><section class="title"><h1><a href="index.html">Octet Api Documentation</a></h1></section><small>Version: 1.1.0</small></header><section class="container"><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>octet</span></div></div></li><li class="depth-2 branch"><a href="octet.buffer.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>buffer</span></div></a></li><li class="depth-2 branch"><a href="octet.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 current"><a href="octet.spec.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>spec</span></div></a></li><li class="depth-3"><a href="octet.spec.reference.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>reference</span></div></a></li><li class="depth-2"><a href="octet.util.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>util</span></div></a></li></ul></div><section class="namespace-docs" id="content"><h2 class="anchor" id="top">octet.spec</h2><div class="doc"><div class="markdown"><p>The spec abstraction.</p>
<p>It includes the basic abstraction protocols for define own type specs and some useful types that allows build asociative or indexed spec compositions.</p>
<p>For more examples see the <code>spec</code> function docstring.</p></div></div><div class="public anchor" id="var-compose"><h3><a href="#var-compose">compose</a></h3><div class="usage"><code>(compose constructor types)</code></div><div class="doc"><div class="markdown"><p>Create a composed typespec with user defined type constructor.</p>
<p>This allows define a typespec with automatic conversion between user data type and serialized data without defining yourself a datatype using low level constructions.</p>
<p>Let see an exameple for understand it better.</p>
<p>Imagine you are have this data type:</p>
<pre><code>(defrecord Point [x y])
</code></pre>
<p>With help of <code>compose</code>, create a new spec for your datatype:</p>
<pre><code>(def point-spec (buf/compose -&gt;Point [buf/int32 buf/int32]))
</code></pre>
<p>Now, you can use the previously defined datatype and typespec for write into buffer:</p>
<pre><code>(buf/write! buffer mypoint point-spec)
;; =&gt; 8
</code></pre>
<p>Or read from the buffer:</p>
<pre><code>(buf/read buffer (point))
;; =&gt; #user.Point{:x 1, :y 2}
</code></pre></div></div><div class="src-link"><a href="http://github.com/funcool/codeina/blob/master/src/octet/spec.cljc#L268">view source</a></div></div><div class="public anchor" id="var-ISpec"><h3><a href="#var-ISpec">ISpec</a></h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><div class="markdown"><p>Basic abstraction for something that can be work like a Spec.</p></div></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-read"><h3><a href="#var-read">read</a></h3><div class="usage"><code>(read _ buff start)</code></div><div class="doc"><div class="markdown"><p>Read all data from buffer.</p></div></div></div><div class="public anchor" id="var-write"><h3><a href="#var-write">write</a></h3><div class="usage"><code>(write _ buff start data)</code></div><div class="doc"><div class="markdown"><p>Read all data from buffer.</p></div></div></div></div></div><div class="src-link"><a href="http://github.com/funcool/codeina/blob/master/src/octet/spec.cljc#L39">view source</a></div></div><div class="public anchor" id="var-ISpecDynamicSize"><h3><a href="#var-ISpecDynamicSize">ISpecDynamicSize</a></h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><div class="markdown"><p>Abstraction for calculate size for dynamic specs.</p></div></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-size*"><h3><a href="#var-size*">size*</a></h3><div class="usage"><code>(size* _ data)</code></div><div class="doc"><div class="markdown"><p>Calculate the size in bytes of the object having a data.</p></div></div></div></div></div><div class="src-link"><a href="http://github.com/funcool/codeina/blob/master/src/octet/spec.cljc#L54">view source</a></div></div><div class="public anchor" id="var-ISpecSize"><h3><a href="#var-ISpecSize">ISpecSize</a></h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><div class="markdown"><p>Abstraction for calculate size of static specs.</p></div></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-size"><h3><a href="#var-size">size</a></h3><div class="usage"><code>(size _)</code></div><div class="doc"><div class="markdown"><p>Calculate the size in bytes of the object.</p></div></div></div></div></div><div class="src-link"><a href="http://github.com/funcool/codeina/blob/master/src/octet/spec.cljc#L50">view source</a></div></div><div class="public anchor" id="var-ISpecWithRef"><h3><a href="#var-ISpecWithRef">ISpecWithRef</a></h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><div class="markdown"><p>Abstraction to support specs having references to other specs within an AssociativeSpec or an IndexedSpec</p></div></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-read*"><h3><a href="#var-read*">read*</a></h3><div class="usage"><code>(read* _ buff start data)</code></div><div class="doc"><div class="markdown"><p>Read data from buffer, use data to calculate length etc</p></div></div></div><div class="public anchor" id="var-write*"><h3><a href="#var-write*">write*</a></h3><div class="usage"><code>(write* _ buff start value types data)</code></div><div class="doc"><div class="markdown"><p>Write data from buffer, use data to store length etc</p></div></div></div></div></div><div class="src-link"><a href="http://github.com/funcool/codeina/blob/master/src/octet/spec.cljc#L44">view source</a></div></div><div class="public anchor" id="var-repeat"><h3><a href="#var-repeat">repeat</a></h3><div class="usage"><code>(repeat n type)</code></div><div class="doc"><div class="markdown"><p>Creare a composed typespec that repeats <code>n</code> times a provided <code>type</code> spec.</p>
<p>As example, create a spec with help of <code>repeat</code> function:</p>
<pre><code>(def spec (buf/repeat 2 buf/int32))
</code></pre>
<p>Write data into buffer using previously defined typespec:</p>
<pre><code>(buf/write! yourbuffer [200 300] spec)
;; =&gt; 8
</code></pre>
<p>Or read data from your buffer using previously defined typespec:</p>
<pre><code>(buf/read yourbuffer spec)
;; =&gt; [200 300]
</code></pre></div></div><div class="src-link"><a href="http://github.com/funcool/codeina/blob/master/src/octet/spec.cljc#L215">view source</a></div></div><div class="public anchor" id="var-spec"><h3><a href="#var-spec">spec</a></h3><div class="usage"><code>(spec &amp; params)</code></div><div class="doc"><div class="markdown"><p>Polymorphic constructor for Spec instances.</p>
<p>Spec is a some kind of composition of arbitrary number of types in associative or indexed data structure.</p>
<p>Little example on how to create associative composition:</p>
<pre><code>(spec :field1 (long)
      :field2 (string 20))
</code></pre>
<p>An other example on how to create indexed composition that represents the same bytes representation that previous one:</p>
<pre><code>(spec (long) (string 20))
</code></pre>
<p>The main difference between the two reprensentation is that if you read a buffer using an associative spec, the result will be clojure hash-map, and if indexed spec is used, the result will be clojure vector containing the values.</p>
<p>The same rules applies for writing data into a buffer.</p></div></div><div class="src-link"><a href="http://github.com/funcool/codeina/blob/master/src/octet/spec.cljc#L174">view source</a></div></div></section></section></body></html>